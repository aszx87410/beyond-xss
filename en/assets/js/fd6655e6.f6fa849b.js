"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[740],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(n),u=a,m=p["".concat(l,".").concat(u)]||p[u]||d[u]||o;return n?i.createElement(m,r(r({ref:t},h),{},{components:n})):i.createElement(m,r({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1280:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={sidebar_position:22},r="Cross-Origin Security Issues",s={unversionedId:"ch4/cors-attack",id:"ch4/cors-attack",title:"Cross-Origin Security Issues",description:"While some websites use reverse proxies or other mechanisms to place the frontend and backend under the same origin, this seems to be the exception rather than the norm. In most cases, allowing frontend access to cross-origin backend APIs is almost inevitable.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/ch4/22-cors-attack.md",sourceDirName:"ch4",slug:"/ch4/cors-attack",permalink:"/beyond-xss/en/ch4/cors-attack",draft:!1,tags:[],version:"current",sidebarPosition:22,frontMatter:{sidebar_position:22},sidebar:"tutorialSidebar",previous:{title:"Introduction to Cross-Origin Resource Sharing (CORS)",permalink:"/beyond-xss/en/ch4/cors-intro"},next:{title:"Cross-Site Request Forgery (CSRF) Made Easy",permalink:"/beyond-xss/en/ch4/csrf"}},l={},c=[{value:"CORS Misconfiguration",id:"cors-misconfiguration",level:2},{value:"Real-World Example",id:"real-world-example",level:3},{value:"Other COXX Series Headers",id:"other-coxx-series-headers",level:2},{value:"Serious Security Vulnerabilities: Meltdown and Spectre",id:"serious-security-vulnerabilities-meltdown-and-spectre",level:2},{value:"Super Simplified Explanation of Spectre Attack",id:"super-simplified-explanation-of-spectre-attack",level:2},{value:"CORB (Cross-Origin Read Blocking)",id:"corb-cross-origin-read-blocking",level:2},{value:"CORP (Cross-Origin Resource Policy)",id:"corp-cross-origin-resource-policy",level:2},{value:"Site Isolation",id:"site-isolation",level:2},{value:"COEP (Cross-Origin-Embedder-Policy)",id:"coep-cross-origin-embedder-policy",level:2},{value:"COOP (Cross-Origin-Opener-Policy)",id:"coop-cross-origin-opener-policy",level:2},{value:"Returning to the cross-origin isolated state",id:"returning-to-the-cross-origin-isolated-state",level:2},{value:"Conclusion",id:"conclusion",level:2}],h={toc:c},p="wrapper";function d(e){let{components:t,...o}=e;return(0,a.kt)(p,(0,i.Z)({},h,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"cross-origin-security-issues"},"Cross-Origin Security Issues"),(0,a.kt)("p",null,"While some websites use reverse proxies or other mechanisms to place the frontend and backend under the same origin, this seems to be the exception rather than the norm. In most cases, allowing frontend access to cross-origin backend APIs is almost inevitable."),(0,a.kt)("p",null,"However, configuring CORS headers may not be as simple as it seems. If misconfigured, it can allow attackers to access resources they shouldn't have access to."),(0,a.kt)("p",null,"In addition to misconfigurations in CORS settings, there are also security concerns with cross-origin access for elements like ",(0,a.kt)("inlineCode",{parentName:"p"},"<img>")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"<script>"),", which we will discuss in this post."),(0,a.kt)("h2",{id:"cors-misconfiguration"},"CORS Misconfiguration"),(0,a.kt)("p",null,"As mentioned earlier, if a cross-origin non-simple request wants to include cookies, the ",(0,a.kt)("inlineCode",{parentName:"p"},"Access-Control-Allow-Origin")," cannot be ",(0,a.kt)("inlineCode",{parentName:"p"},"*"),". It must specify a single origin; otherwise, the browser will not allow it."),(0,a.kt)("p",null,"But in reality, we cannot have just one origin. We may have multiple origins, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"buy.example.com"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"social.example.org"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"note.example.com.tw"),", all needing to access ",(0,a.kt)("inlineCode",{parentName:"p"},"api.example.com"),". In this case, we cannot hardcode the origin in the response header; it needs to be dynamically adjusted."),(0,a.kt)("p",null,"Let's start with the worst approach, which is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"app.use((req, res, next) => {\n  res.headers['Access-Control-Allow-Credentials'] = 'true'\n  res.headers['Access-Control-Allow-Origin'] = req.headers['Origin']\n})\n")),(0,a.kt)("p",null,"The origin is directly taken from the request header for convenience. By doing this, any origin can pass the CORS check."),(0,a.kt)("p",null,"What problems does this approach have?"),(0,a.kt)("p",null,"It has significant issues."),(0,a.kt)("p",null,"Let's say I create a website with the URL ",(0,a.kt)("inlineCode",{parentName:"p"},"https://fake-example.com")," and try to get users to click on it. Inside the website, there is a script:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// send a request with cookie\nfetch('https://api.example.com/me', {\n  credentials: 'include'\n})\n  .then(res => res.text())\n  .then(res => {\n    // got user data, and I can send it to my server\n    console.log(res)\n\n    // redirect back to the real service\n    window.location = 'https://example.com'\n  })\n")),(0,a.kt)("p",null,"Because the server returns the correct header, recognizing ",(0,a.kt)("inlineCode",{parentName:"p"},"https://fake-example.com")," as a valid origin, the CORS check passes. Therefore, this website can also retrieve data from ",(0,a.kt)("inlineCode",{parentName:"p"},"http://api.example.com/me"),"."),(0,a.kt)("p",null,"As a result, this attack will only affect users who visit the website and are logged into ",(0,a.kt)("inlineCode",{parentName:"p"},"example.com"),". The impact depends on the website's API. At a minimum, it can access user data, and in more severe cases, it may obtain the user's token (if such an API exists)."),(0,a.kt)("p",null,"There are a few things to note about this attack:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"This is not XSS because I am not executing code on ",(0,a.kt)("inlineCode",{parentName:"li"},"example.com"),". I am executing it on my own website, ",(0,a.kt)("inlineCode",{parentName:"li"},"http://fake-example.com"),"."),(0,a.kt)("li",{parentName:"ol"},"It is somewhat similar to CSRF, but websites usually do not add CSRF token protection to GET APIs, so it can pass."),(0,a.kt)("li",{parentName:"ol"},"If SameSite cookies are set, the attack will fail because the cookie will not be sent.")),(0,a.kt)("p",null,"(CSRF and SameSite will be discussed later)"),(0,a.kt)("p",null,"Therefore, for this attack to succeed, several prerequisites must be met:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"CORS headers are given to an unauthorized origin."),(0,a.kt)("li",{parentName:"ol"},"The website uses cookies for authentication and does not set SameSite."),(0,a.kt)("li",{parentName:"ol"},"The user actively clicks on the website and is logged in.")),(0,a.kt)("p",null,"Regarding the first point, it is unlikely that anyone would write code like the example above, directly using the origin from the request header. A more likely approach is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"app.use((req, res, next) => {\n  res.headers['Access-Control-Allow-Credentials'] = 'true'\n  const origin = req.headers['Origin']\n\n  if (/example\\.com$/.test(origin)) {\n    res.headers['Access-Control-Allow-Origin'] = origin\n  }\n})\n")),(0,a.kt)("p",null,"This way, the following origins can pass:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"example.com"),(0,a.kt)("li",{parentName:"ol"},"buy.example.com"),(0,a.kt)("li",{parentName:"ol"},"social.example.com")),(0,a.kt)("p",null,"However, this approach has a problem because this can also pass:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"fakeexample.com")),(0,a.kt)("p",null,"Vulnerabilities like this are caused by incorrect CORS settings and are therefore called CORS misconfigurations."),(0,a.kt)("p",null,"The solution is not to use RegExp for checking but to prepare an allow-list in advance. Only origins that appear in the list can pass; otherwise, they will fail. This way, we can ensure that there are no vulnerabilities in the checking process and remember to add the SameSite attribute to cookies."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const allowOrigins = [\n  'https://example.com',\n  'https://buy.example.com',\n  'https://social.example.com'\n]\napp.use((req, res, next) => {\n  res.headers['Access-Control-Allow-Credentials'] = 'true'\n  const origin = req.headers['Origin']\n\n  if (allowOrigins.includes(origin)) {\n    res.headers['Access-Control-Allow-Origin'] = origin\n  }\n})\n")),(0,a.kt)("h3",{id:"real-world-example"},"Real-World Example"),(0,a.kt)("p",null,"The first example is a vulnerability found by Jordan Milne in JetBrains IDE in 2016."),(0,a.kt)("p",null,'When using JetBrains IDE, it runs a local server. When you open a file and click "view in browser," it opens the URL: ',(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:63342/<projectname>/<your_file.html>"),", which is handled by the local server behind the scenes."),(0,a.kt)("p",null,"And this server is not well implemented. Its ",(0,a.kt)("inlineCode",{parentName:"p"},"Access-Control-Allow-Origin")," header is just like the wrong example I mentioned earlier, directly using the origin header from the request. Therefore, any website can read the response."),(0,a.kt)("p",null,"Furthermore, the author discovered a path traversal vulnerability, which allows accessing any file through this API. Therefore, when combined, it means that an attacker can read files on the system through the JetBrains local server API on their website."),(0,a.kt)("p",null,"The simple PoC provided by the author is as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<script>\nvar xhr = new XMLHttpRequest();\nxhr.open("GET", "http://localhost:63342/testing/something.txt", true);\nxhr.onload = function() {alert(xhr.responseText)};\nxhr.send();\n<\/script>\n')),(0,a.kt)("p",null,"Later, the author found other issues and successfully achieved RCE (Remote Code Execution). However, those parts are unrelated to the CORS configuration issue discussed in this article, so I won't go into detail. If you are interested, you can refer to the original article: ",(0,a.kt)("a",{parentName:"p",href:"http://blog.saynotolinux.com/blog/2016/08/15/jetbrains-ide-remote-code-execution-and-local-file-disclosure-vulnerability-analysis/"},"JetBrains IDE Remote Code Execution and Local File Disclosure"),"."),(0,a.kt)("p",null,"The second case is about a vulnerability in a Bitcoin exchange shared by James Kettle at the 2017 AppSec EU conference."),(0,a.kt)("p",null,"He found that one of the exchange's APIs had the same vulnerability, allowing any origin to read the response. One of the APIs was ",(0,a.kt)("inlineCode",{parentName:"p"},"/api/requestApiKey"),", which could retrieve the user's apiKey. This apiKey could be used to transfer the user's bitcoins to another account."),(0,a.kt)("p",null,"For more information, you can refer to: ",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=wgkj4ZgxI4c&ab_channel=OWASP"},"AppSec EU 2017 Exploiting CORS Misconfigurations For Bitcoins And Bounties by James Kettle"),"."),(0,a.kt)("p",null,"Lastly, let's look at the vulnerability I reported for Asiayo in 2020. The root cause is exactly the same, allowing other websites to access user data, including names, phone numbers, and email addresses:"),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(8720).Z,width:"1201",height:"153"})),(0,a.kt)("p",null,"Original report(in Mardarin): ",(0,a.kt)("a",{parentName:"p",href:"https://zeroday.hitcon.org/vulnerability/ZD-2020-00829"},"Asiayo Website CORS Misconfiguration Vulnerability")),(0,a.kt)("h2",{id:"other-coxx-series-headers"},"Other COXX Series Headers"),(0,a.kt)("p",null,"In addition to the familiar CORS, there are several headers starting with CO:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"CORB (Cross-Origin Read Blocking)"),(0,a.kt)("li",{parentName:"ol"},"CORP (Cross-Origin Resource Policy)"),(0,a.kt)("li",{parentName:"ol"},"COEP (Cross-Origin-Embedder-Policy)"),(0,a.kt)("li",{parentName:"ol"},"COOP (Cross-Origin-Opener-Policy)")),(0,a.kt)("p",null,"These headers with CO are also related to cross-origin data access. Now let's take a look at what these headers are doing."),(0,a.kt)("h2",{id:"serious-security-vulnerabilities-meltdown-and-spectre"},"Serious Security Vulnerabilities: Meltdown and Spectre"),(0,a.kt)("p",null,"On January 3, 2018, Google's Project Zero released an article titled ",(0,a.kt)("a",{parentName:"p",href:"https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html"},"Reading privileged memory with a side-channel"),", which described three attacks targeting CPU data cache:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Variant 1: bounds check bypass (CVE-2017-5753)"),(0,a.kt)("li",{parentName:"ul"},"Variant 2: branch target injection (CVE-2017-5715)"),(0,a.kt)("li",{parentName:"ul"},"Variant 3: rogue data cache load (CVE-2017-5754)")),(0,a.kt)("p",null,"The first two are known as Spectre, and the third one is known as Meltdown. If you remember, this was a big issue at the time because the problem was with the CPU and not an easy one to fix."),(0,a.kt)("p",null,"I think the disclosure of this vulnerability had a significant impact on the operation mechanism of browsers (or at least accelerated the evolution of browsers). Especially, Spectre can be used to attack browsers, which also affects the topic of this series: Cross-Origin Resource Sharing."),(0,a.kt)("p",null,"Therefore, it is necessary to have a basic understanding of what Spectre is doing. To fully understand this attack, a lot of background knowledge is required, but that is not the main focus of this article. So, below I will explain Spectre using a highly simplified model. If you want to fully understand it, you can refer to the link above."),(0,a.kt)("h2",{id:"super-simplified-explanation-of-spectre-attack"},"Super Simplified Explanation of Spectre Attack"),(0,a.kt)("p",null,"Again, it is important to note that this is a simplified version for easier understanding. It may differ from the original attack, but the core concept should be similar."),(0,a.kt)("p",null,"Let's assume we have a piece of code (in C language) that looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"uint8_t arr1[16] = {1, 2, 3}; \nuint8_t arr2[256]; \nunsigned int array1_size = 16;\n\nvoid run(size_t x) {\n  if(x < array1_size) {\n    uint8_t y = array2[array1[x]];\n  }\n}\n\nsize_t x = 1;\nrun(x);\n")),(0,a.kt)("p",null,"I have declared two arrays of type ",(0,a.kt)("inlineCode",{parentName:"p"},"uint8_t"),", so each element in the arrays will be 1 byte (8 bits) in size. The length of ",(0,a.kt)("inlineCode",{parentName:"p"},"arr1")," is 16, and the length of ",(0,a.kt)("inlineCode",{parentName:"p"},"arr2")," is 256."),(0,a.kt)("p",null,"Next, I have a function called ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," which takes a number ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," as input. It checks if ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," is smaller than ",(0,a.kt)("inlineCode",{parentName:"p"},"array1_size"),". If it is, it retrieves the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"array1[x]"),", uses it as an index to access ",(0,a.kt)("inlineCode",{parentName:"p"},"array2"),", and assigns the retrieved value to ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),"."),(0,a.kt)("p",null,"In the example above, if we call ",(0,a.kt)("inlineCode",{parentName:"p"},"run(1)"),", it will execute:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-C"},"uint8_t y = array2[array1[1]];\n")),(0,a.kt)("p",null,"Since the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"array1[1]")," is 2, it becomes ",(0,a.kt)("inlineCode",{parentName:"p"},"y = array2[2]"),"."),(0,a.kt)("p",null,"This code seems fine and I have also added a check for array length, so there won't be any out-of-bounds (OOB) access unless ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," is smaller than ",(0,a.kt)("inlineCode",{parentName:"p"},"array1_size"),"."),(0,a.kt)("p",null,"However, this is just how it appears to you."),(0,a.kt)("p",null,"When the CPU executes the code, there is a mechanism called branch prediction. To improve code execution efficiency, the CPU predicts whether the if condition will be true or false. If the prediction is true, it executes the code inside the if statement and calculates the result in advance."),(0,a.kt)("p",null,'All of this is just "prediction". After the actual execution of the if condition, if the result matches the prediction, everything is fine. But if it doesn\'t match, the previously calculated result is discarded. This mechanism is called speculative execution.'),(0,a.kt)("p",null,"Because the CPU discards the result, we cannot directly access the speculative execution result unless there are some clues left by the CPU."),(0,a.kt)("p",null,"And this is the main reason why Spectre attack works, because there are indeed some clues left."),(0,a.kt)("p",null,"To further improve execution efficiency, during speculative execution, some results are stored in the CPU cache to enhance data retrieval efficiency."),(0,a.kt)("p",null,"Let's say we have three things: A, B, and C. One of them is in the CPU cache, and the other two are not. How can we determine which one is in the cache?"),(0,a.kt)("p",null,"The answer is by observing the access time of these three things! Since accessing something in the CPU cache is faster, if accessing A takes 10ms, B takes 10ms, and C only takes 1ms, we can conclude that C is in the CPU cache. This type of attack that obtains information through other channels is called a side-channel attack."),(0,a.kt)("p",null,"In the above method, we determine based on time, so it is also known as a timing attack."),(0,a.kt)("p",null,"Now, let's go back to the previous code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"uint8_t arr1[16] = {1, 2, 3}; \nuint8_t arr2[256]; \nunsigned int array1_size = 16;\n\nvoid run(size_t x) {\n  if(x < array1_size) {\n    uint8_t y = array2[array1[x]];\n  }\n}\n\nsize_t x = 1;\nrun(x);\n")),(0,a.kt)("p",null,"Assume that we run ",(0,a.kt)("inlineCode",{parentName:"p"},"run(10)")," multiple times. Based on branch prediction, the CPU reasonably predicts that the next execution will also satisfy the if condition and executes the code inside. At this moment, I suddenly set ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," to 100 and run ",(0,a.kt)("inlineCode",{parentName:"p"},"run(100)"),"."),(0,a.kt)("p",null,"The code inside the if statement will be speculatively executed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-C"},"uint8_t y = array2[array1[100]];\n")),(0,a.kt)("p",null,"Let's say the value of ",(0,a.kt)("inlineCode",{parentName:"p"},"array1[100]")," is 38. So it becomes ",(0,a.kt)("inlineCode",{parentName:"p"},"y = array2[38]"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"array2[38]")," is stored in the CPU cache, enhancing the efficiency of subsequent data retrieval."),(0,a.kt)("p",null,"Then, during the actual execution, the if condition is found to be false, so the previously obtained result is discarded, and nothing happens. The function execution is completed."),(0,a.kt)("p",null,"Now, based on the timing attack we discussed earlier, we read each element of ",(0,a.kt)("inlineCode",{parentName:"p"},"array2")," and measure the time. We will find that the access time for ",(0,a.kt)("inlineCode",{parentName:"p"},"array2[38]")," is the shortest."),(0,a.kt)("p",null,"At this point, we know one thing:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The content of ",(0,a.kt)("inlineCode",{parentName:"p"},"array1[100]")," is 38.")),(0,a.kt)("p",null,'You might ask, "So what can you do with this information?" There are many things you can do. Since the length of ',(0,a.kt)("inlineCode",{parentName:"p"},"array1")," is only 16, the value we read is not from ",(0,a.kt)("inlineCode",{parentName:"p"},"array1")," itself but from other parts of memory that we should not have accessed. By continuously replicating this pattern, we can read data from other places."),(0,a.kt)("p",null,"If this attack is performed in a browser, I can read data from other websites within the same process. In other words, if there is content from other websites within the same process, I can access that content!"),(0,a.kt)("p",null,"This is the Spectre attack, which exploits certain mechanisms of the CPU to perform a side-channel attack and read data that should not be accessible, causing security issues."),(0,a.kt)("p",null,'In simple terms, "Spectre allows you to potentially read data from other websites while using a browser."'),(0,a.kt)("p",null,"The explanation of Spectre ends here. The details have been simplified above, and I don't fully understand those details either. If you want to know more, you can refer to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html"},"Reading privileged memory with a side-channel")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://zhuanlan.zhihu.com/p/32757727"},"Interpreting Meltdown & Spectre CPU vulnerabilities")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://yangrz.github.io/blog/2018/01/09/cpu/"},"A discussion on processor-level Spectre Attack and Poc analysis")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://www.ptt.cc/bbs/NetSecurity/M.1515146856.A.750.html"},"[Chat] Introduction to Spectre & Meltdown vulnerabilities (translation)")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/hdzitao/spectre-attack-zh"},"Spectre vulnerability example code comments")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://developers.google.com/web/updates/2018/02/meltdown-spectre"},"Google update: Meltdown/Spectre")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://security.googleblog.com/2018/07/mitigating-spectre-with-site-isolation.html"},"Mitigating Spectre with Site Isolation in Chrome"))),(0,a.kt)("p",null,"As for the COXX stuff, their purpose is similar, which is to prevent one website from being able to read data from other websites. As long as malicious websites and target websites are not in the same process, this type of attack is ineffective."),(0,a.kt)("p",null,"From this perspective, let's take a look at various related mechanisms."),(0,a.kt)("h2",{id:"corb-cross-origin-read-blocking"},"CORB (Cross-Origin Read Blocking)"),(0,a.kt)("p",null,"About a month after the public disclosure of the Spectre attack by Google, in February 2018, they published a blog post explaining what Chrome did to prevent this type of attack: ",(0,a.kt)("a",{parentName:"p",href:"https://developers.google.com/web/updates/2018/02/meltdown-spectre"},"Meltdown/Spectre"),"."),(0,a.kt)("p",null,"The Cross-Site Document Blocking mentioned in the article is the predecessor of CORB. According to ",(0,a.kt)("a",{parentName:"p",href:"https://www.chromestatus.com/feature/5629709824032768"},"Chrome Platform Status"),", it was officially enabled by default in Chrome for desktop release 67, which was around May 2018. Around the same time, it was merged into the fetch spec and became part of the specification (",(0,a.kt)("a",{parentName:"p",href:"https://github.com/whatwg/fetch/pull/686"},"CORB: blocking of nosniff and 206 responses"),")."),(0,a.kt)("p",null,"As mentioned earlier, Spectre can read data under the same process. So one way to defend against it is to prevent data from other websites from appearing under the same process."),(0,a.kt)("p",null,"A website has many ways to bring in cross-origin resources, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"fetch")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"xhr"),", but these two methods are already controlled by CORS, and the response obtained should be stored in a network-related process rather than the website's own process. Therefore, even with Spectre, it cannot be read."),(0,a.kt)("p",null,"However, using ",(0,a.kt)("inlineCode",{parentName:"p"},"<img>")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"<script>")," tags can easily load resources from other websites. For example: ",(0,a.kt)("inlineCode",{parentName:"p"},'<img src="https://bank.com/secret.json">'),". Suppose ",(0,a.kt)("inlineCode",{parentName:"p"},"secret.json"),' is confidential data, we can "load" this confidential data.'),(0,a.kt)("p",null,"You may wonder, \"What's the point of doing this? It's not an image, and I can't access it with JavaScript either.\" That's right, it's not an image, but in terms of Chrome's operation mechanism, Chrome doesn't know it's not an image before downloading it (it could have a file extension of .json but actually be an image), so it downloads it first. After downloading, it sends the result to the render process, and only then does it realize that it's not an image, triggering a loading error."),(0,a.kt)("p",null,'It may seem like there\'s no problem, but don\'t forget that Spectre opened a new window where "any data in the same process can be potentially read." Therefore, just "sending the result to the render process" is not enough because through Spectre attacks, attackers can still access data stored in memory.'),(0,a.kt)("p",null,"Therefore, the purpose of the CORB mechanism is:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"If the data type you want to read is completely unreasonable, there is no need to read it into the render process, just discard the result!")),(0,a.kt)("p",null,"Continuing with the example above, if the MIME type of that JSON file is ",(0,a.kt)("inlineCode",{parentName:"p"},"application/json"),', it means that it cannot be an image, so it cannot be placed inside an img tag. This is what I mean by "unreasonable data type to read".'),(0,a.kt)("p",null,"CORB mainly protects three types of data: HTML, XML, and JSON. How does the browser know if it is one of these three types? Let's determine it from the content type in the response header, right?"),(0,a.kt)("p",null,"Unfortunately, it's not possible. The reason is that many websites have incorrectly set content types. It is possible that a JavaScript file is set as ",(0,a.kt)("inlineCode",{parentName:"p"},"text/html"),", and then CORB blocks it, causing the website to break."),(0,a.kt)("p",null,"Therefore, Chrome will detect (sniffing) the file type based on its content to decide whether to apply CORB or not."),(0,a.kt)("p",null,"However, there is also a possibility of misjudgment. So, if the content type provided by your server is always correct, you can send a response header ",(0,a.kt)("inlineCode",{parentName:"p"},"X-Content-Type-Options: nosniff"),", and Chrome will directly use the content type you provided instead of sniffing it."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"CORB error message",src:n(2555).Z,width:"896",height:"98"})),(0,a.kt)("p",null,"In summary, CORB is a mechanism that is already built into Chrome. It automatically blocks the loading of unreasonable cross-origin resources, such as using ",(0,a.kt)("inlineCode",{parentName:"p"},"<img>")," to load JSON or using ",(0,a.kt)("inlineCode",{parentName:"p"},"<script>")," to load HTML, and so on."),(0,a.kt)("p",null,"For more detailed explanations, you can refer to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://www.chromium.org/Home/chromium-security/corb-for-developers"},"Cross-Origin Read Blocking for Web Developers")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://chromium.googlesource.com/chromium/src/+/master/services/network/cross_origin_read_blocking_explainer.md"},"Cross-Origin Read Blocking (CORB)"))),(0,a.kt)("h2",{id:"corp-cross-origin-resource-policy"},"CORP (Cross-Origin Resource Policy)"),(0,a.kt)("p",null,"CORB is a built-in mechanism in browsers that automatically protects HTML, XML, and JSON from being loaded into cross-origin render processes, thus preventing Spectre attacks. But what about other resources? If there are other types of resources, such as certain photos and videos that are also sensitive data, can I protect them?"),(0,a.kt)("p",null,"This is where the CORP HTTP response header comes into play. CORP, formerly known as From-Origin, is described in the following quote from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/whatwg/fetch/issues/687"},"Cross-Origin-Resource-Policy (was: From-Origin) #687"),":"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Cross-Origin Read Blocking (CORB) automatically protects against Spectre attacks that load cross-origin, cross-type HTML, XML, and JSON resources, and is based on the browser\u2019s ability to distinguish resource types. We think CORB is a good idea. From-Origin would offer servers an opt-in protection beyond CORB.")),(0,a.kt)("p",null,"If you know which resources need to be protected, you can use the CORP header to specify which sources can load these resources. CORP has three options:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"same-site"),(0,a.kt)("li",{parentName:"ol"},"same-origin"),(0,a.kt)("li",{parentName:"ol"},"cross-origin")),(0,a.kt)("p",null,"The third option is similar to not setting it (but there is still a difference, which will be explained later), meaning that all cross-origin sources can load the resource. Let's see what happens after setting this!"),(0,a.kt)("p",null,"First, let's run a simple server using express, add the CORP header, and place an image with the URL ",(0,a.kt)("inlineCode",{parentName:"p"},"http://b.example.com/logo.jpg"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"app.use((req, res, next) => {\n  res.header('Cross-Origin-Resource-Policy', 'same-origin')\n  next()\n})\napp.use(express.static('public'));\n")),(0,a.kt)("p",null,"Then, in ",(0,a.kt)("inlineCode",{parentName:"p"},"http://a.example.com"),", let's include this image:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<img src="http://b.example.com/logo.jpg" />\n')),(0,a.kt)("p",null,"When you refresh and open the console, you will see an error message indicating that the image failed to load. Opening the network tab will provide a detailed explanation of the reason:"),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(3961).Z,width:"1110",height:"574"})),(0,a.kt)("p",null,"If you change the header to ",(0,a.kt)("inlineCode",{parentName:"p"},"same-site")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"cross-origin"),", you will be able to see the image loaded correctly."),(0,a.kt)("p",null,'So, this header is actually a "resource-level CORS". The original CORS is more like a protocol for accessing APIs or "data" between different origins, allowing cross-origin access to data with permission. However, when it comes to loading resources such as using ',(0,a.kt)("inlineCode",{parentName:"p"},"<img>")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"<script>"),", if you want to prevent cross-origin loading, you could only rely on server-side logic to determine the ",(0,a.kt)("inlineCode",{parentName:"p"},"Origin")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"Referer")," values and dynamically decide whether to return the data."),(0,a.kt)("p",null,'With the introduction of the CORP header, it provides a method to block "any cross-origin loading" by simply setting a header. So, it\'s not just about security considerations; security is just one aspect. The key is that you can prevent others from loading your resources.'),(0,a.kt)("p",null,"As mentioned in the ",(0,a.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/from-origin"},"spec")," of the predecessor of CORP, From-Origin:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The Web platform has no limitations on embedding resources from different origins currently. E.g. an HTML document on ",(0,a.kt)("a",{parentName:"p",href:"http://example.org"},"http://example.org")," can embed an image from ",(0,a.kt)("a",{parentName:"p",href:"http://corp.invalid"},"http://corp.invalid")," without issue. This has led to a number of problems:")),(0,a.kt)("p",null,"For this type of embedded resource, the Web platform currently has no limitations on what can be loaded. Although it is convenient, it can also cause some problems, such as:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Inline linking \u2014 the practice of embedding resources (e.g. images or fonts) from another server, causing the owner of that server to get a higher hosting bill."),(0,a.kt)("p",{parentName:"blockquote"},"Clickjacking \u2014 embedding a resource from another origin and attempting to let the visitor click on a concealed link thereof, causing harm to the visitor.")),(0,a.kt)("p",null,"For example, directly linking to images from someone else's server on my blog would result in the traffic and hosting bill being attributed to that server. Additionally, there can be clickjacking issues."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Privacy leakage \u2014 sometimes resource availability depends on whether a visitor is signed in to a particular website. E.g. only with a I'm-signed-in-cookie will an image be returned, and if there is no such cookie an HTML document. An HTML document embedding such a resource (requested with the user's credentials) can figure out the existence of that resource and thus whether the visitor is signed in and therefore has an account with a particular service.")),(0,a.kt)("p",null,"There are also privacy concerns. For example, a website can determine whether you are logged in on other websites (which will be discussed later)."),(0,a.kt)("p",null,"How does it know? Because some resources may only be accessible when logged in. Let's say a certain image URL only returns the image correctly when logged in, and returns a server error otherwise. I can simply write this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},"<img src=xxx onerror=\"alert('not login')\" onload=\"alert('login')\">\n")),(0,a.kt)("p",null,"By checking whether the image is loaded successfully, I can determine if you are logged in."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"License checking \u2014 certain font licenses require that the font be prevented from being embedded on other origins.")),(0,a.kt)("p",null,"Font websites may prevent users without a license from loading fonts, and this header is also suitable for such situations."),(0,a.kt)("p",null,'In summary, the earlier introduction of CORB only "prevents unreasonable reading," such as loading HTML using img, which is purely for security considerations.'),(0,a.kt)("p",null,"However, CORP can prevent any reading (except for iframes, which are not affected by it) and can protect the resources of your website from being loaded by others. It is a more powerful and widely applicable header."),(0,a.kt)("p",null,"Nowadays, mainstream browsers already support this header."),(0,a.kt)("h2",{id:"site-isolation"},"Site Isolation"),(0,a.kt)("p",null,"To prevent Spectre attacks, there are two approaches:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Prevent attackers from having the opportunity to execute Spectre attacks."),(0,a.kt)("li",{parentName:"ol"},"Even if the attack is executed, prevent obtaining the desired information.")),(0,a.kt)("p",null,"The principle of Spectre attacks was mentioned earlier, which involves determining which data is stored in the cache by measuring the time it takes to read the data. By doing so, attackers can \"steal\" data from memory. If the timing provided by the browser's timer function is intentionally imprecise, wouldn't that defend against the attack? Because the calculated time by the attacker would be similar, they wouldn't know which read is faster."),(0,a.kt)("p",null,"After the appearance of Spectre attacks, browsers took two actions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Reduced the precision of ",(0,a.kt)("inlineCode",{parentName:"li"},"performance.now"),"."),(0,a.kt)("li",{parentName:"ol"},"Disabled ",(0,a.kt)("inlineCode",{parentName:"li"},"SharedArrayBuffer"),".")),(0,a.kt)("p",null,"The first point is easy to understand; by reducing the precision of the timing function, attackers cannot determine the correct reading speed. But why the second point?"),(0,a.kt)("p",null,"Let's talk about ",(0,a.kt)("inlineCode",{parentName:"p"},"SharedArrayBuffer"),". This allows JavaScript in your document to share the same block of memory with web workers, enabling data sharing. So, in a web worker, you can create a counter that keeps incrementing, and then read this counter in JavaScript, achieving the functionality of a timer."),(0,a.kt)("p",null,'Therefore, after Spectre appeared, browsers made these two adjustments, starting from the perspective of "preventing the source of the attack," which is the first approach.'),(0,a.kt)("p",null,"The other approach is to prevent malicious websites from accessing information from cross-origin websites, which was mentioned earlier as CORB and now introducing: Site Isolation."),(0,a.kt)("p",null,'This term was briefly mentioned in the "Browser Security Model" section. Let\'s start with an introduction from ',(0,a.kt)("a",{parentName:"p",href:"https://developers.google.com/web/updates/2018/07/site-isolation"},"Site Isolation for web developers"),":"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Site Isolation is a security feature in Chrome that offers an additional line of defense to make such attacks less likely to succeed. It ensures that pages from different websites are always put into different processes, each running in a sandbox that limits what the process is allowed to do. It also blocks the process from receiving certain types of sensitive data from other sites.")),(0,a.kt)("p",null,"In simple terms, Site Isolation ensures that resources from different websites are placed in different processes. Therefore, even if a Spectre attack is executed on your own website, it doesn't matter because it cannot read data from other websites."),(0,a.kt)("p",null,"Site Isolation is currently enabled by default in Chrome. The corresponding drawback is that it consumes more memory because more processes are created. For other impacts, you can refer to the aforementioned article."),(0,a.kt)("p",null,'In addition to Site Isolation, there is another concept that is easily confused, called "cross-origin isolated state."'),(0,a.kt)("p",null,"What is the difference between these two? According to my understanding, the article ",(0,a.kt)("a",{parentName:"p",href:"https://security.googleblog.com/2018/07/mitigating-spectre-with-site-isolation.html"},"Mitigating Spectre with Site Isolation in Chrome")," mentions:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},'Note that Chrome uses a specific definition of "site" that includes just the scheme and registered domain. Thus, ',(0,a.kt)("a",{parentName:"p",href:"https://google.co.uk"},"https://google.co.uk")," would be a site, and subdomains like ",(0,a.kt)("a",{parentName:"p",href:"https://maps.google.co.uk"},"https://maps.google.co.uk")," would stay in the same process.")),(0,a.kt)("p",null,'The definition of "Site" in Site Isolation is the same as the same-site concept. For example, ',(0,a.kt)("inlineCode",{parentName:"p"},"http://a.example.com")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"http://b.example.com")," are considered the same site. Therefore, even under Site Isolation, these two web pages would still be placed in the same process."),(0,a.kt)("p",null,"And the cross-origin isolated state should be a stronger isolation, isolating everything that is not the same origin, even if it is the same site. Therefore, ",(0,a.kt)("inlineCode",{parentName:"p"},"http://a.example.com")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"http://b.example.com")," will be isolated. Moreover, Site Isolation isolates processes, while cross-origin isolated appears to isolate browsing context groups, preventing cross-origin resources from being in the same browsing context group."),(0,a.kt)("p",null,"This cross-origin isolated state is not enabled by default and requires setting up these two headers on the webpage:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Embedder-Policy: require-corp"),(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Opener-Policy: same-origin")),(0,a.kt)("p",null,"As for why these two headers, I will explain later."),(0,a.kt)("h2",{id:"coep-cross-origin-embedder-policy"},"COEP (Cross-Origin-Embedder-Policy)"),(0,a.kt)("p",null,"To achieve the cross-origin isolated state, it is necessary to ensure that all cross-origin accesses on your website are legitimate and authorized."),(0,a.kt)("p",null,"The COEP (Cross-Origin-Embedder-Policy) header has two values:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"unsafe-none"),(0,a.kt)("li",{parentName:"ol"},"require-corp")),(0,a.kt)("p",null,'The first one is the default value, which means there are no restrictions. The second one is related to CORP (Cross-Origin-Resource-Policy) mentioned earlier. If you use require-corp, it means telling the browser, "All resources I load on the page must have the CORP header (or CORS) and be legitimate."'),(0,a.kt)("p",null,"Now, let's assume we have a website ",(0,a.kt)("inlineCode",{parentName:"p"},"a.example.com")," and we want to make it a cross-origin isolated state. Therefore, we add a header to it: ",(0,a.kt)("inlineCode",{parentName:"p"},"Cross-Origin-Embedder-Policy: require-corp"),". Then, we import a resource in the webpage:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-html"},'<img src="http://b.example.com/logo.jpg">\n')),(0,a.kt)("p",null,"Next, we send the correct header on the ",(0,a.kt)("inlineCode",{parentName:"p"},"b")," side:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"app.use((req, res, next) => {\n  res.header('Cross-Origin-Resource-Policy', 'cross-origin')\n  next()\n})\n")),(0,a.kt)("p",null,"This way, the first step is achieved."),(0,a.kt)("p",null,"Also, I mentioned earlier that there is a slight difference between not setting CORP and setting it as ",(0,a.kt)("inlineCode",{parentName:"p"},"cross-origin"),", and it lies here. In the example above, if the ",(0,a.kt)("inlineCode",{parentName:"p"},"b")," side does not send this header, the Embedder Policy will not pass."),(0,a.kt)("h2",{id:"coop-cross-origin-opener-policy"},"COOP (Cross-Origin-Opener-Policy)"),(0,a.kt)("p",null,"The second step is the COOP (Cross-Origin-Opener-Policy) header. When you use ",(0,a.kt)("inlineCode",{parentName:"p"},"window.open")," to open a webpage, you can manipulate the location of that webpage, and the opened webpage can also manipulate your webpage using ",(0,a.kt)("inlineCode",{parentName:"p"},"window.opener"),"."),(0,a.kt)("p",null,"Having such a connection between windows does not comply with cross-origin isolation. Therefore, the COOP header is used to regulate the relationship between windows and openers. It has three values:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Opener-Policy: ",(0,a.kt)("inlineCode",{parentName:"li"},"unsafe-none")),(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Opener-Policy: ",(0,a.kt)("inlineCode",{parentName:"li"},"same-origin")),(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Opener-Policy: ",(0,a.kt)("inlineCode",{parentName:"li"},"same-origin-allow-popups"))),(0,a.kt)("p",null,"The first one is the default value, and it doesn't have any effect, so I won't explain it. The other two are a bit more complicated. Let's summarize them with a simple example."),(0,a.kt)("p",null,"Suppose there is a webpage A that opens a webpage B using ",(0,a.kt)("inlineCode",{parentName:"p"},"window.open"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"If AB is cross-origin, the browser already has restrictions and can only access methods like ",(0,a.kt)("inlineCode",{parentName:"li"},"window.location")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"window.close"),". It cannot access the DOM or anything else."),(0,a.kt)("li",{parentName:"ol"},"If AB is same-origin, they can access each other's windows almost entirely, including the DOM."),(0,a.kt)("li",{parentName:"ol"},"If A adds the COOP header with a value of ",(0,a.kt)("inlineCode",{parentName:"li"},"same-origin"),", it means imposing additional restrictions on the second case. Both A and B must have this header with a value of ",(0,a.kt)("inlineCode",{parentName:"li"},"same-origin")," to access each other's windows."),(0,a.kt)("li",{parentName:"ol"},"If A adds the COOP header with a value of ",(0,a.kt)("inlineCode",{parentName:"li"},"same-origin-allow-popups"),", it also restricts the second case but is more lenient. As long as B's COOP header is not ",(0,a.kt)("inlineCode",{parentName:"li"},"same-origin"),", they can access each other's windows.")),(0,a.kt)("p",null,'In summary, to have the "opportunity to access each other\'s windows," they must first be the same origin, and this is unchangeable. Whether they can access each other depends on whether the COOP header is set and the value of the header.'),(0,a.kt)("p",null,"If the COOP header is set but does not comply with the rules, ",(0,a.kt)("inlineCode",{parentName:"p"},"window.opener")," will become ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," directly, and even the location cannot be obtained (if no rules are set, it can be obtained even if it is cross-origin)."),(0,a.kt)("p",null,"In fact, according to the ",(0,a.kt)("a",{parentName:"p",href:"https://html.spec.whatwg.org/multipage/origin.html#cross-origin-opener-policies"},"spec"),", there is also a fourth type: same-origin-plus-COEP, but it seems more complicated, so let's not study it for now."),(0,a.kt)("h2",{id:"returning-to-the-cross-origin-isolated-state"},"Returning to the cross-origin isolated state"),(0,a.kt)("p",null,"As mentioned earlier, the cross-origin isolated state requires setting these two headers:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Embedder-Policy: require-corp"),(0,a.kt)("li",{parentName:"ol"},"Cross-Origin-Opener-Policy: same-origin")),(0,a.kt)("p",null,"Why? Because once set, it means that you have permission to access all cross-origin resources on the page. If you don't have permission, an error will occur. So if it is set and passes, it means that you are allowed to access all cross-origin resources, and there will be no security issues."),(0,a.kt)("p",null,"On the website, you can use:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"self.crossOriginIsolated\n")),(0,a.kt)("p",null,"to determine if you have entered the cross-origin isolated state. If so, you can use some restricted features because the browser knows you are secure."),(0,a.kt)("p",null,"In addition, if you enter this state, the trick of bypassing the same-origin policy by modifying ",(0,a.kt)("inlineCode",{parentName:"p"},"document.domain")," mentioned earlier will no longer work. The browser will not allow you to modify this anymore."),(0,a.kt)("p",null,"To learn more about COOP, COEP, and the cross-origin isolated state, you can refer to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://web.dev/coop-coep/"},'Making your website "cross-origin isolated" using COOP and COEP')),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://web.dev/why-coop-coep/"},'Why you need "cross-origin isolated" for powerful features')),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://scotthelme.co.uk/coop-and-coep/"},"COEP COOP CORP CORS CORB - CRAP that's a lot of new stuff!")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/whatwg/html/issues/4175"},"Making postMessage() work for SharedArrayBuffer (Cross-Origin-Embedder-Policy) #4175")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/whatwg/html/issues/3740"},"Restricting cross-origin WindowProxy access (Cross-Origin-Opener-Policy) #3740")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("a",{parentName:"li",href:"https://www.chromestatus.com/feature/4647328103268352"},"Feature: Cross-Origin Resource Policy"))),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"This article actually covers a lot of things, all revolving around security. We first discussed the consequences of incorrect CORS settings and defense methods, and provided several practical examples."),(0,a.kt)("p",null,"Then, we talked about various headers starting with CO:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"CORB (Cross-Origin Read Blocking)"),(0,a.kt)("li",{parentName:"ol"},"CORP (Cross-Origin Resource Policy)"),(0,a.kt)("li",{parentName:"ol"},"COEP (Cross-Origin-Embedder-Policy)"),(0,a.kt)("li",{parentName:"ol"},"COOP (Cross-Origin-Opener-Policy)")),(0,a.kt)("p",null,"If we were to summarize these four things in a sentence each, it might be:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"CORB: The default mechanism of the browser, mainly to prevent loading unreasonable resources, such as loading HTML with ",(0,a.kt)("inlineCode",{parentName:"li"},"<img>")),(0,a.kt)("li",{parentName:"ol"},"CORP: An HTTP response header that determines who can load this resource, preventing cross-origin loading of images, videos, or any resources"),(0,a.kt)("li",{parentName:"ol"},"COEP: An HTTP response header that ensures all resources on the page are loaded legitimately"),(0,a.kt)("li",{parentName:"ol"},"COOP: An HTTP response header that adds stricter window sharing settings to same-origin")),(0,a.kt)("p",null,"The reason for the extensive length of this article is that, on one hand, there are many details to explain, and on the other hand, it shows the importance of the origin concept to the browser, so important that it requires so many measures to protect and ensure the same-origin policy."),(0,a.kt)("p",null,"After reading through all these same-origin and cross-origin things, let's switch gears in the next article and take a look at the classic CSRF."))}d.isMDXComponent=!0},8720:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/22-01-7996e373152b0341b07c18d6498f2259.png"},2555:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/22-02-83e532426aa5c1b67b4a64bb25d1795e.png"},3961:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/22-03-926b42b4f629cf27973e9877ba120244.png"}}]);