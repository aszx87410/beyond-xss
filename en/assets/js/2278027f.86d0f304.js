"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[991],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(n),h=i,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||a;return n?r.createElement(m,s(s({ref:t},p),{},{components:n})):r.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:i,s[1]=o;for(var u=2;u<a;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},708:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>u});var r=n(7462),i=(n(7294),n(3905));const a={sidebar_position:9},s="Latest XSS Defense: Trusted Types and Built-in Sanitizer API",o={unversionedId:"ch2/trust-types",id:"ch2/trust-types",title:"Latest XSS Defense: Trusted Types and Built-in Sanitizer API",description:"When discussing XSS defense, I mentioned the need to handle user input. If HTML is allowed, it is necessary to find a reliable package to handle it.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/ch2/09-trust-types.md",sourceDirName:"ch2",slug:"/ch2/trust-types",permalink:"/beyond-xss/en/ch2/trust-types",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"The Third Line of Defense against XSS: Reducing the Impact Scope",permalink:"/beyond-xss/en/ch2/token-storage"},next:{title:"Bypassing Your Defenses: Common CSP Bypasses",permalink:"/beyond-xss/en/ch2/csp-bypass"}},l={},u=[{value:"Sanitizer API",id:"sanitizer-api",level:2},{value:"Trusted Types",id:"trusted-types",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:u},c="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"latest-xss-defense-trusted-types-and-built-in-sanitizer-api"},"Latest XSS Defense: Trusted Types and Built-in Sanitizer API"),(0,i.kt)("p",null,"When discussing XSS defense, I mentioned the need to handle user input. If HTML is allowed, it is necessary to find a reliable package to handle it."),(0,i.kt)("p",null,"Many websites have such requirements, so browsers have gradually started providing related functionalities."),(0,i.kt)("p",null,"Creating a new feature from scratch usually takes a long time, from proposal and specification to implementation, which can take several years. The topics of Trusted Types and Sanitizer API discussed in this article are currently only supported by Chromium-based browsers. They have not been officially supported in the latest versions of Firefox (119) and Safari (17) yet. Therefore, the content mentioned in this article can be considered as a reference for future use in production when the time is right."),(0,i.kt)("h2",{id:"sanitizer-api"},"Sanitizer API"),(0,i.kt)("p",null,"Sanitizer API is the built-in sanitizer provided by browsers. It is quite similar to the previously mentioned DOMPurify in terms of usage. Here is an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html>\n<body>\n  <div id=content></div>\n  <script>\n    const html = `\n      Hello,\n      <script>alert(1)<\\/script>\n      <img src=x onerror=alert(1)>\n      <a href=javascript:alert(1)>click me</a>\n      <h1 onclick=alert(1) id=a>title</h1>\n      <iframe></iframe>\n    `; \n    const sanitizer = new Sanitizer(); \n    document\n      .querySelector("#content")\n      .setHTML(html, { sanitizer });\n  <\/script>\n</body>\n</html>\n')),(0,i.kt)("p",null,"To work with the Sanitizer API, a new method called ",(0,i.kt)("inlineCode",{parentName:"p"},"setHTML")," has been added. By passing the original HTML and the sanitizer, the Sanitizer API can perform filtering."),(0,i.kt)("p",null,"The filtered result of the above HTML is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},"Hello,\n<img src=x>\n<a>click me</a>\n<h1 id=a>title</h1>\n")),(0,i.kt)("p",null,'All dangerous elements have been removed. The goal of the Sanitizer API is to ensure that "no matter how you use it or configure it, XSS will not occur." This is both an advantage and a disadvantage. Let me give you another example to make it clear:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},"<!DOCTYPE html>\n<html>\n<body>\n  <div id=content></div>\n  <script>\n    const html = `\n      Hello, this is my channel:\n      <iframe src=https://www.youtube.com/watch?v=123></iframe>\n    `; \n    const sanitizer = new Sanitizer({\n      allowElements: ['iframe'],\n      allowAttributes: {\n        'iframe': ['src']\n      }\n    }); \n    document\n      .querySelector(\"#content\")\n      .setHTML(html, { sanitizer });\n    /*\n        result: Hello, this is my channel:\n    */\n  <\/script>\n</body>\n</html>\n")),(0,i.kt)("p",null,"The configuration file states that iframes are allowed, including the ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," attribute. However, in the final result, the iframe is still removed. This is because, as I mentioned earlier, the Sanitizer API guarantees that you can never use dangerous tags. So, regardless of the configuration, iframes are not allowed."),(0,i.kt)("p",null,"Someone has also raised this issue in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/WICG/sanitizer-api/issues/124"},"Allow Embedding #124"),'. The biggest problem is that once iframes are allowed and the assumption of "being safe no matter what" is maintained, there are many things to consider.'),(0,i.kt)("p",null,"For example, if filtering is applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," attribute, should the URLs inside it be filtered? Should ",(0,i.kt)("inlineCode",{parentName:"p"},"data:")," URLs be removed? What about ",(0,i.kt)("inlineCode",{parentName:"p"},"srcdoc"),"? Should it also be re-filtered? This issue is still open and has been inactive for over a year."),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://wicg.github.io/sanitizer-api/#baseline-elements"},"specification of the Sanitizer API")," defines a list of baseline elements and baseline attributes. Since it is quite long, I won't paste it here. If the element or attribute you want to add is not in this list, there is no way to use it no matter what."),(0,i.kt)("p",null,"This can be considered both an advantage and a disadvantage of the Sanitizer API. Although it may lack flexibility, the advantage is that no matter how it is used, there won't be any issues. Unlike the third-party packages we introduced before, there is a possibility of issues if the configuration is not properly adjusted."),(0,i.kt)("p",null,"Currently, the Sanitizer API is still in its early stages. Perhaps, in the future, when all mainstream browsers support the Sanitizer API and it can achieve the desired features, it can be considered whether to switch to it."),(0,i.kt)("p",null,"Although I still recommend using DOMPurify for sanitization, it's good to have an understanding of the Sanitizer API as well."),(0,i.kt)("p",null,"If you want to learn more about how to use it, you can refer to Google's article on ",(0,i.kt)("a",{parentName:"p",href:"https://web.dev/sanitizer/"},"Safe DOM manipulation with the Sanitizer API"),"."),(0,i.kt)("h2",{id:"trusted-types"},"Trusted Types"),(0,i.kt)("p",null,"Trusted Types, like the Sanitizer API, is also very new and currently only supported by Chromium-based browsers. So, it's just good to have a look for now, as it is not yet mature."),(0,i.kt)("p",null,"When rendering user data on the frontend, we need to constantly ensure that the user input is properly escaped to prevent XSS vulnerabilities. However, there are many places where things can go wrong, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"innerHTML"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<iframe srcdoc>"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"document.write"),", etc. If we directly pass unprocessed input to them, it creates an XSS vulnerability."),(0,i.kt)("p",null,"Besides developers being cautious when writing code, are there any other methods to prevent issues in these places? For example, suppose I execute ",(0,i.kt)("inlineCode",{parentName:"p"},"div.innerHTML = str"),", and if ",(0,i.kt)("inlineCode",{parentName:"p"},"str")," is an unprocessed string, it throws an error and stops execution. This way, XSS occurrences can be reduced."),(0,i.kt)("p",null,"Yes, this is what Trusted Types does."),(0,i.kt)("p",null,"After adding Trusted Types to CSP, Trusted Types can be enabled to protect these DOM APIs, forcing the browser to go through Trusted Types processing before inserting HTML:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Content-Security-Policy: require-trusted-types-for 'script';\n")),(0,i.kt)("p",null,"Here is an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},'<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv="Content-Security-Policy" content="require-trusted-types-for \'script\'">\n</head>\n<body>\n  <div id=content></div>\n  <script>\n    document.querySelector("#content").innerHTML = \'<h1>hello</h1>\'\n  <\/script>\n</body>\n</html>\n')),(0,i.kt)("p",null,"The above code will throw an error when executed, with the following message:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This document requires 'TrustedHTML' assignment. Uncaught TypeError: Failed to set the 'innerHTML' property on 'Element': This document requires 'TrustedHTML' assignment.")),(0,i.kt)("p",null,"Once Trusted Types are enforced, you can no longer directly pass a string to ",(0,i.kt)("inlineCode",{parentName:"p"},"innerHTML"),". Instead, you need to create a new Trusted Types policy to handle dangerous HTML. Here's how it's done:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-html"},"<!DOCTYPE html>\n<html>\n<head>\n  <meta http-equiv=\"Content-Security-Policy\" content=\"require-trusted-types-for 'script'\">\n</head>\n<body>\n  <div id=content></div>\n  <script>\n    // create a new policy\n    const sanitizePolicy = trustedTypes.createPolicy('sanitizePolicy', {\n      // add sanitize/escape\n      createHTML: (string) => string\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, '&gt;')\n    });\n    // The type of safeHtml is TrustedHTML, not String\n    const safeHtml = sanitizePolicy.createHTML('<h1>hello</h1>')\n    document.querySelector(\"#content\").innerHTML = safeHtml\n  <\/script>\n</body>\n</html>\n")),(0,i.kt)("p",null,'The purpose of Trusted Types is not to "ensure your HTML is problem-free," but rather to "force the use of Trusted Types on potentially problematic DOM APIs and disallow the use of strings." This significantly reduces many risks. When you accidentally forget to handle user input, the browser will throw an error instead of rendering the unprocessed string as HTML.'),(0,i.kt)("p",null,"Therefore, after enabling Trusted Types, you only need to focus on the implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"createHTML")," and ensure that these implementations are secure. Additionally, from the above example, you can see that the content of ",(0,i.kt)("inlineCode",{parentName:"p"},"createHTML")," is determined by us, so it can also be combined with DOMPurify."),(0,i.kt)("p",null,"What about combining it with the Sanitizer API? It is possible, and this is also the recommended approach in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/WICG/sanitizer-api/blob/main/faq.md#can-i-use-the-sanitizer-api-together-with-trusted-types"},"official documentation"),":"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Can I use the Sanitizer API together with Trusted Types?"),(0,i.kt)("p",{parentName:"blockquote"},"Yes, please. We see these as APIs that solve different aspects of the same problem. They are separate but should work well together.\nDetails of Santizer API/Trusted Types integration are still being worked out.")),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"In this article, we have seen two new APIs: Sanitizer and Trusted Types. These APIs are quite significant for frontend security, as they represent browsers actively providing support for sanitization, allowing us developers to have more defenses against attacks."),(0,i.kt)("p",null,"Although these two APIs are not yet mature, in the not-so-distant future, we may see them gradually becoming mainstream. Some frontend frameworks have already caught up with them, such as ",(0,i.kt)("a",{parentName:"p",href:"https://angular.io/guide/security#enforcing-trusted-types"},"Angular")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/vercel/next.js/issues/32209"},"Next.js"),", which are either discussing or already have support for Trusted Types."),(0,i.kt)("p",null,"If you want to try Trusted Types in production ahead of time, you can use this polyfill provided by W3C: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/w3c/trusted-types"},"https://github.com/w3c/trusted-types")))}d.isMDXComponent=!0}}]);